<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>hw_4</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-11-01">
<meta name="DC.source" content="hw_4.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#2">Preperation of the workspace</a>
</li>
<li>
<a href="#3">Setting data paths</a>
</li>
<li>
<a href="#4">Problem 2 in Chapter 4</a>
</li>
<li>
<a href="#5">Problem 6 in Chapter 4</a>
</li>
<li>
<a href="#6">Problem 8 in Chapter 4</a>
</li>
<li>
<a href="#7">Functions</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="comment">%{
</span><span class="comment">
</span><span class="comment">@author: Benjamin Bemis Ph.D Student,
</span><span class="comment">Advisor: Dr Juliano
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">Description:
</span><span class="comment">AME 60614: Numerical Methods
</span><span class="comment">Homework: 4
</span><span class="comment">Due: 10/31/2024
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">%}</span>
</pre>
<h2 id="2">Preperation of the workspace</h2>
<pre class="codeinput">clear <span class="string">all</span>
clc
close <span class="string">all</span>
fontsize = 16;


<span class="comment">% set(0,'DefaultFigureWindowStyle','docked')</span>
set(0,<span class="string">'DefaultTextInterpreter'</span>,<span class="string">'latex'</span>)
set(0,<span class="string">'DefaultAxesFontSize'</span>,fontsize)
set(0,<span class="string">'DefaultLegendFontSize'</span>,fontsize)
colors  = [<span class="string">"#000000"</span>,<span class="string">"#1b9e77"</span>,<span class="string">"#d95f02"</span>,<span class="string">"#7570b3"</span>,<span class="string">"#0099FF"</span>]';
</pre>
<h2 id="3">Setting data paths</h2>
<p>Make sure to update this for the machine that you are working on. (Maybe, This should now run on any machine without change. 7/24/24) Change the current folder to the folder of this m-file.</p>
<pre class="codeinput">
<span class="keyword">if</span>(~isdeployed)
  cd(fileparts(matlab.desktop.editor.getActiveFilename));
<span class="keyword">end</span>

addpath(cd)
<span class="comment">% cd ..; % Moving up a directory (from processing_code)</span>
basepath = cd; <span class="comment">% Pulling the current directory</span>

<span class="keyword">if</span> isunix

    imagepath = [basepath <span class="string">'/images/'</span>]; <span class="comment">% Unix</span>
    mkdir(imagepath);

<span class="keyword">elseif</span> ispc

    imagepath = [basepath <span class="string">'\images\'</span>]; <span class="comment">% Windows</span>
    mkdir(imagepath);

<span class="keyword">else</span>
    disp(<span class="string">'Platform not supported'</span>)
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">Warning: Directory already exists. 
</pre>
<h2 id="4">Problem 2 in Chapter 4</h2>
<pre class="codeinput">exact = @(t) 0.90991./(exp(0.2*t) + 0.900901*sin(2*t) - 0.0900901*cos(2*t));
f = @(t,y) (-0.2*y) - (2*cos(2*t)*y^2);
y0 = 1;
t0 = 0;
tf = 7;
h = [0.2 0.05 0.025 0.006];

figure
plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
hold <span class="string">on</span>
<span class="keyword">for</span> n = 1:size(h,2)
       [t,y] = explicitEuler(f, y0, t0, tf, h(n));
       plot(t,y,<span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
       hold <span class="string">on</span>
<span class="keyword">end</span>

xlabel(<span class="string">'$t$ (sec)'</span>)
ylabel(<span class="string">'$v$'</span>)
grid <span class="string">on</span>
xlim([t0 tf])
ylim([0 1.4])
legend(Location=<span class="string">"best"</span>,Interpreter=<span class="string">"latex"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q2.png'</span>],<span class="string">'-dpng'</span>);


emax=1e-6;      <span class="comment">% Convergence Tolerance</span>
residual_error = 1;
h = 0.2
y_prev = [];
converged = false;
<span class="keyword">while</span> ~converged

 [t,y] = explicitEuler(f, y0, t0, tf, h);

    <span class="comment">% If there is a previous solution, compute the L2 norm difference</span>
    <span class="keyword">if</span> ~isempty(y_prev)
        <span class="comment">% Interpolate previous solution onto the current time points for comparison</span>
        y_prev_interp = interp1(t_prev, y_prev, t, <span class="string">'linear'</span>, <span class="string">'extrap'</span>);

        <span class="comment">% Calculate the L2 norm of the difference between current and previous solution</span>
        residual_error = sqrt(sum((y - y_prev_interp).^2) * h);

        <span class="comment">% Check if residual error is below the tolerance and greater than</span>
        <span class="comment">% initial step</span>
        <span class="keyword">if</span> residual_error &lt; emax &amp;&amp; h &lt; 0.1
            converged = true;
            disp([<span class="string">'Converged with step size h = '</span>, num2str(h), <span class="string">' and L2 norm error = '</span>, num2str(residual_error)]);
        <span class="keyword">else</span>
            <span class="comment">% If not converged, halve the step size</span>
            h = h / 2;
            disp([<span class="string">'Step size halved to h = '</span>, num2str(h), <span class="string">' with L2 norm error = '</span>, num2str(residual_error)]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Update previous solution and time points for the next iteration</span>
    y_prev = y;
    t_prev = t;

<span class="keyword">end</span>

figure
plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
hold <span class="string">on</span>

plot(t,y,<span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h)) , color=colors(2,:))

xlabel(<span class="string">'$t$ (sec)'</span>)
ylabel(<span class="string">'$v$'</span>)
grid <span class="string">on</span>
xlim([t0 tf])
ylim([0 1.4])
legend(Location=<span class="string">"best"</span>,Interpreter=<span class="string">"latex"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q2_c.png'</span>],<span class="string">'-dpng'</span>);
</pre>
<img vspace="5" hspace="5" src="hw_4_01.png" alt=""> <img vspace="5" hspace="5" src="hw_4_02.png" alt=""> <h2 id="5">Problem 6 in Chapter 4</h2>
<pre class="codeinput">funlist = {@explicitEuler, @implicitEuler,@trapMethod,@RK2,@RK4};
funlist_str = [<span class="string">"Explicit Euler"</span>, <span class="string">"Implicit Euler"</span>,<span class="string">"Trapizoidal Method"</span>,<span class="string">"RK2"</span>,<span class="string">"RK4"</span>];
f = @(t,y) -((3*t)/(1+t))*y - (2*(1+t)^3*exp(-t));
y0 = 1;
t0 = 0;
tf = 15;
h = [0.2 0.8 1.1];
exact = @(t) -exp(-3*t).*(exp(2*t) - 2).*(t + 1).^3;
<span class="keyword">for</span> i = 1:length(funlist)
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(h)

    [t,y] = funlist{i}(f, y0, t0, tf, h(n));
    plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
    hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$v$'</span>)
    legend(Location=<span class="string">"best"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-4 1])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q6'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);
<span class="keyword">end</span>
</pre>
<img vspace="5" hspace="5" src="hw_4_03.png" alt=""> <img vspace="5" hspace="5" src="hw_4_04.png" alt=""> <img vspace="5" hspace="5" src="hw_4_05.png" alt=""> <img vspace="5" hspace="5" src="hw_4_06.png" alt=""> <img vspace="5" hspace="5" src="hw_4_07.png" alt=""> <h2 id="6">Problem 8 in Chapter 4</h2>
<pre class="codeinput">funlist2 = {@explicitEuler_2, @implicitEuler_2,@trapMethod_2,@RK2_2,@RK4_2};
funlist_str = [<span class="string">"Explicit Euler"</span>, <span class="string">"Implicit Euler"</span>,<span class="string">"Trapizoidal Method"</span>,<span class="string">"RK2"</span>,<span class="string">"RK4"</span>];
exact = @(t) 10*cos(4.04351*t);
exact2 = @(t) exp(-2* t).* (5.6911* sin(3.51426 *t) + 10 *cos(3.51426*t));
exact3 = @(t) pi/3 *cos(4.04351 *t);
g = 9.81; <span class="comment">%m/s^2</span>
l = 0.6; <span class="comment">%m</span>
c = 4;
theta0= 10; <span class="comment">%deg</span>
thetap0 = 0; <span class="comment">% assume at rest</span>
f_theta = @(t, theta, thetap) -g/l *theta ;
f_theta_2 = @(t, theta, thetap) -g/l *theta -c*thetap ;
f_theta_3 = @(t, theta, thetap) -g/l *sin(theta) ;



t0 = 0;
tf = 6;
h = [.15 .5 1];
hi = [.15 .05 .001]
<span class="keyword">for</span> i = 1:length(funlist2)
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(h)

        [t,y,yp] = funlist2{i}(f_theta,theta0,thetap0, t0, tf, h(n));
        plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
        hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$\theta$ (deg)'</span>)
    legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-20 20])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q8_a'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);



    figure
    plot(linspace(t0,tf,1e3),exact2(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(h)

        [t,y,yp] = funlist2{i}(f_theta_2,theta0,thetap0, t0, tf, h(n));
        plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
        hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$\theta$ (deg)'</span>)
    legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-20 20])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q8_b'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);



    figure
    plot(linspace(t0,tf,1e3),exact3(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(hi)

        [t,y,yp] = funlist2{i}(f_theta_3,pi/3,thetap0, t0, tf, hi(n));
        plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(hi(n))) , color=colors(n+1,:))
        hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$\theta$ (rad)'</span>)
    legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-5 5])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q8_c'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);

<span class="keyword">end</span>
</pre>
<pre class="codeoutput">
hi =

    0.1500    0.0500    0.0010

</pre>
<img vspace="5" hspace="5" src="hw_4_08.png" alt=""> <img vspace="5" hspace="5" src="hw_4_09.png" alt=""> <img vspace="5" hspace="5" src="hw_4_10.png" alt=""> <img vspace="5" hspace="5" src="hw_4_11.png" alt=""> <img vspace="5" hspace="5" src="hw_4_12.png" alt=""> <img vspace="5" hspace="5" src="hw_4_13.png" alt=""> <img vspace="5" hspace="5" src="hw_4_14.png" alt=""> <img vspace="5" hspace="5" src="hw_4_15.png" alt=""> <img vspace="5" hspace="5" src="hw_4_16.png" alt=""> <img vspace="5" hspace="5" src="hw_4_17.png" alt=""> <img vspace="5" hspace="5" src="hw_4_18.png" alt=""> <img vspace="5" hspace="5" src="hw_4_19.png" alt=""> <img vspace="5" hspace="5" src="hw_4_20.png" alt=""> <img vspace="5" hspace="5" src="hw_4_21.png" alt=""> <img vspace="5" hspace="5" src="hw_4_22.png" alt=""> <h2 id="7">Functions</h2>
<pre class="codeinput">
<span class="keyword">function</span> [t, y] = explicitEuler(f, y0, t0, tf, h)
    <span class="comment">% explicitEuler solves an ODE using the explicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the explicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        y(n+1) = y(n) + h * f(t(n), y(n));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = implicitEuler(f, y0, t0, tf, h)
    <span class="comment">% implicitEuler solves an ODE using the implicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Options for fsolve to increase accuracy and ensure convergence</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the implicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the function for the nonlinear equation at each step</span>
        g = @(ynext) ynext - y(n) - h * f(t(n+1), ynext);

        <span class="comment">% Use fsolve to solve for y(n+1)</span>
        y(n+1) = fsolve(g, y(n), options);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = trapMethod(f, y0, t0, tf, h)
    <span class="comment">% trapMethod solves an ODE using the trapezoidal method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Options for fsolve to increase accuracy and ensure convergence</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the trapezoidal method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the function for the nonlinear equation at each step</span>
        g = @(ynext) ynext - y(n) - (h/2) * (f(t(n), y(n)) + f(t(n+1), ynext));

        <span class="comment">% Use fsolve to solve for y(n+1)</span>
        y(n+1) = fsolve(g, y(n), options);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = RK2(f, y0, t0, tf, h)
    <span class="comment">% RK2 solves an ODE using the 2nd-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the 2nd-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        y(n+1) = y(n) + h * k2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = RK4(f, y0, t0, tf, h)
    <span class="comment">% RK4 solves an ODE using the 4th-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the 4th-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        k3 = f(t(n) + h/2, y(n) + h/2 * k2);
        k4 = f(t(n) + h, y(n) + h * k3);
        y(n+1) = y(n) + (h/6) * (k1 + 2*k2 + 2*k3 + k4);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = explicitEuler_2(f, y0, v0, t0, tf, h)
    <span class="comment">% A general second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the explicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the explicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Update y1 and y2</span>
        y1(n+1) = y1(n) + h * y2(n);
        y2(n+1) = y2(n) + h * f(t(n), y1(n), y2(n));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = implicitEuler_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the implicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Options for fsolve</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the implicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the system of equations to solve at each step</span>
        func = @(Y_next) [
            Y_next(1) - y1(n) - h * Y_next(2);          <span class="comment">% y1^{n+1} = y1^n + h * y2^{n+1}</span>
            Y_next(2) - y2(n) - h * f(t(n+1), Y_next(1), Y_next(2))  <span class="comment">% y2^{n+1} = y2^n + h * f(t^{n+1}, y1^{n+1}, y2^{n+1})</span>
        ];

        <span class="comment">% Initial guess for fsolve</span>
        Y_guess = [y1(n), y2(n)];

        <span class="comment">% Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve</span>
        Y_next = fsolve(func, Y_guess, options);

        <span class="comment">% Update y1 and y2 with the solved values</span>
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = trapMethod_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the trapezoidal (implicit) method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Options for fsolve</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the trapezoidal method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the system of equations to solve at each step</span>
        func = @(Y_next) [
            Y_next(1) - y1(n) - h/2 * (y2(n) + Y_next(2));  <span class="comment">% y1^{n+1} = y1^n + h/2 * (y2^n + y2^{n+1})</span>
            Y_next(2) - y2(n) - h/2 * (f(t(n), y1(n), y2(n)) + f(t(n+1), Y_next(1), Y_next(2))) <span class="comment">% y2^{n+1} = y2^n + h/2 * (f_n + f_{n+1})</span>
        ];

        <span class="comment">% Initial guess for fsolve</span>
        Y_guess = [y1(n), y2(n)];

        <span class="comment">% Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve</span>
        Y_next = fsolve(func, Y_guess, options);

        <span class="comment">% Update y1 and y2 with the solved values</span>
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = RK2_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the second-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the second-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Calculate k1 values</span>
        k1y1 = h * y2(n);
        k1y2 = h * f(t(n), y1(n), y2(n));

        <span class="comment">% Calculate k2 values</span>
        k2y1 = h * (y2(n) + k1y2 / 2);
        k2y2 = h * f(t(n) + h / 2, y1(n) + k1y1 / 2, y2(n) + k1y2 / 2);

        <span class="comment">% Update y1 and y2</span>
        y1(n+1) = y1(n) + k2y1;
        y2(n+1) = y2(n) + k2y2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = RK4_2(f, y0, v0, t0, tf, h)
    <span class="comment">% RK4_2</span>

    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (y(t0) = y0)</span>
    <span class="comment">%   v0 - Initial condition for y' (y'(t0) = v0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y'</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the 4th-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Calculate k1 values</span>
        k1_y1 = y2(n);
        k1_y2 = f(t(n), y1(n), y2(n));

        <span class="comment">% Calculate k2 values</span>
        k2_y1 = y2(n) + h/2 * k1_y2;
        k2_y2 = f(t(n) + h/2, y1(n) + h/2 * k1_y1, y2(n) + h/2 * k1_y2);

        <span class="comment">% Calculate k3 values</span>
        k3_y1 = y2(n) + h/2 * k2_y2;
        k3_y2 = f(t(n) + h/2, y1(n) + h/2 * k2_y1, y2(n) + h/2 * k2_y2);

        <span class="comment">% Calculate k4 values</span>
        k4_y1 = y2(n) + h * k3_y2;
        k4_y2 = f(t(n) + h, y1(n) + h * k3_y1, y2(n) + h * k3_y2);

        <span class="comment">% Update y1 and y2 using weighted average of slopes</span>
        y1(n+1) = y1(n) + (h/6) * (k1_y1 + 2*k2_y1 + 2*k3_y1 + k4_y1);
        y2(n+1) = y2(n) + (h/6) * (k1_y2 + 2*k2_y2 + 2*k3_y2 + k4_y2);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<pre class="codeoutput">
h =

    0.2000

Step size halved to h = 0.1 with L2 norm error = 0
Step size halved to h = 0.05 with L2 norm error = 0.28934
Step size halved to h = 0.025 with L2 norm error = 0.20358
Step size halved to h = 0.0125 with L2 norm error = 0.13601
Step size halved to h = 0.00625 with L2 norm error = 0.082385
Step size halved to h = 0.003125 with L2 norm error = 0.046103
Step size halved to h = 0.0015625 with L2 norm error = 0.024514
Step size halved to h = 0.00078125 with L2 norm error = 0.012658
Step size halved to h = 0.00039063 with L2 norm error = 0.0064345
Step size halved to h = 0.00019531 with L2 norm error = 0.0032442
Step size halved to h = 9.7656e-05 with L2 norm error = 0.001629
Step size halved to h = 4.8828e-05 with L2 norm error = 0.0008162
Step size halved to h = 2.4414e-05 with L2 norm error = 0.00040853
Step size halved to h = 1.2207e-05 with L2 norm error = 0.00020437
Step size halved to h = 6.1035e-06 with L2 norm error = 0.00010221
Step size halved to h = 3.0518e-06 with L2 norm error = 5.1113e-05
Step size halved to h = 1.5259e-06 with L2 norm error = 2.5558e-05
Step size halved to h = 7.6294e-07 with L2 norm error = 1.278e-05
Step size halved to h = 3.8147e-07 with L2 norm error = 6.3899e-06
Step size halved to h = 1.9073e-07 with L2 norm error = 3.195e-06
Step size halved to h = 9.5367e-08 with L2 norm error = 1.5975e-06
Converged with step size h = 9.5367e-08 and L2 norm error = 7.9875e-07
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%{

@author: Benjamin Bemis Ph.D Student, 
Advisor: Dr Juliano


Description:
AME 60614: Numerical Methods
Homework: 4
Due: 10/31/2024


%}

%% Preperation of the workspace
clear all 
clc 
close all
fontsize = 16;


% set(0,'DefaultFigureWindowStyle','docked')
set(0,'DefaultTextInterpreter','latex')
set(0,'DefaultAxesFontSize',fontsize)
set(0,'DefaultLegendFontSize',fontsize)
colors  = ["#000000","#1b9e77","#d95f02","#7570b3","#0099FF"]';

%% Setting data paths
% Make sure to update this for the machine that you are working on. (Maybe, This should now run on any machine without change. 7/24/24)
% Change the current folder to the folder of this m-file.
if(~isdeployed)
  cd(fileparts(matlab.desktop.editor.getActiveFilename));
end

addpath(cd)
% cd ..; % Moving up a directory (from processing_code)
basepath = cd; % Pulling the current directory

if isunix

    imagepath = [basepath '/images/']; % Unix
    mkdir(imagepath);

elseif ispc

    imagepath = [basepath '\images\']; % Windows
    mkdir(imagepath);

else
    disp('Platform not supported')
end


%% Problem 2 in Chapter 4
exact = @(t) 0.90991./(exp(0.2*t) + 0.900901*sin(2*t) - 0.0900901*cos(2*t));
f = @(t,y) (-0.2*y) - (2*cos(2*t)*y^2);
y0 = 1;
t0 = 0;
tf = 7;
h = [0.2 0.05 0.025 0.006];

figure
plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
hold on
for n = 1:size(h,2)
       [t,y] = explicitEuler(f, y0, t0, tf, h(n));
       plot(t,y,"-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
       hold on
end

xlabel('$t$ (sec)')
ylabel('$v$')
grid on
xlim([t0 tf])
ylim([0 1.4])
legend(Location="best",Interpreter="latex")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q2.png'],'-dpng');


emax=1e-6;      % Convergence Tolerance
residual_error = 1;
h = 0.2
y_prev = [];
converged = false;
while ~converged
    
 [t,y] = explicitEuler(f, y0, t0, tf, h);

    % If there is a previous solution, compute the L2 norm difference
    if ~isempty(y_prev)
        % Interpolate previous solution onto the current time points for comparison
        y_prev_interp = interp1(t_prev, y_prev, t, 'linear', 'extrap');
        
        % Calculate the L2 norm of the difference between current and previous solution
        residual_error = sqrt(sum((y - y_prev_interp).^2) * h);
        
        % Check if residual error is below the tolerance and greater than
        % initial step
        if residual_error < emax && h < 0.1
            converged = true;
            disp(['Converged with step size h = ', num2str(h), ' and L2 norm error = ', num2str(residual_error)]);
        else
            % If not converged, halve the step size
            h = h / 2;
            disp(['Step size halved to h = ', num2str(h), ' with L2 norm error = ', num2str(residual_error)]);
        end
    end
    
    % Update previous solution and time points for the next iteration
    y_prev = y;
    t_prev = t;

end

figure
plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
hold on

plot(t,y,"-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h)) , color=colors(2,:))

xlabel('$t$ (sec)')
ylabel('$v$')
grid on
xlim([t0 tf])
ylim([0 1.4])
legend(Location="best",Interpreter="latex")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q2_c.png'],'-dpng');


%% Problem 6 in Chapter 4
funlist = {@explicitEuler, @implicitEuler,@trapMethod,@RK2,@RK4};
funlist_str = ["Explicit Euler", "Implicit Euler","Trapizoidal Method","RK2","RK4"];
f = @(t,y) -((3*t)/(1+t))*y - (2*(1+t)^3*exp(-t));
y0 = 1;
t0 = 0;
tf = 15;
h = [0.2 0.8 1.1];
exact = @(t) -exp(-3*t).*(exp(2*t) - 2).*(t + 1).^3;
for i = 1:length(funlist)
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(h) 

    [t,y] = funlist{i}(f, y0, t0, tf, h(n));
    plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
    hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$v$')
    legend(Location="best",Interpreter="latex")
    xlim([t0 tf])
    ylim([-4 1])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q6',char(string(i)),'.png'],'-dpng');
end




%% Problem 8 in Chapter 4
funlist2 = {@explicitEuler_2, @implicitEuler_2,@trapMethod_2,@RK2_2,@RK4_2};
funlist_str = ["Explicit Euler", "Implicit Euler","Trapizoidal Method","RK2","RK4"];
exact = @(t) 10*cos(4.04351*t);
exact2 = @(t) exp(-2* t).* (5.6911* sin(3.51426 *t) + 10 *cos(3.51426*t));
exact3 = @(t) pi/3 *cos(4.04351 *t);
g = 9.81; %m/s^2
l = 0.6; %m
c = 4; 
theta0= 10; %deg
thetap0 = 0; % assume at rest
f_theta = @(t, theta, thetap) -g/l *theta ; 
f_theta_2 = @(t, theta, thetap) -g/l *theta -c*thetap ; 
f_theta_3 = @(t, theta, thetap) -g/l *sin(theta) ; 



t0 = 0;
tf = 6;
h = [.15 .5 1];
hi = [.15 .05 .001]
for i = 1:length(funlist2) 
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(h)

        [t,y,yp] = funlist2{i}(f_theta,theta0,thetap0, t0, tf, h(n));
        plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
        hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$\theta$ (deg)')
    legend(Location="southeast",Interpreter="latex")
    xlim([t0 tf])
    ylim([-20 20])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q8_a',char(string(i)),'.png'],'-dpng');



    figure
    plot(linspace(t0,tf,1e3),exact2(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(h)

        [t,y,yp] = funlist2{i}(f_theta_2,theta0,thetap0, t0, tf, h(n));
        plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
        hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$\theta$ (deg)')
    legend(Location="southeast",Interpreter="latex")
    xlim([t0 tf])
    ylim([-20 20])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q8_b',char(string(i)),'.png'],'-dpng');



    figure
    plot(linspace(t0,tf,1e3),exact3(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(hi)

        [t,y,yp] = funlist2{i}(f_theta_3,pi/3,thetap0, t0, tf, hi(n));
        plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(hi(n))) , color=colors(n+1,:))
        hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$\theta$ (rad)')
    legend(Location="southeast",Interpreter="latex")
    xlim([t0 tf])
    ylim([-5 5])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q8_c',char(string(i)),'.png'],'-dpng');

end


%% Functions

function [t, y] = explicitEuler(f, y0, t0, tf, h)
    % explicitEuler solves an ODE using the explicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the explicit Euler method
    for n = 1:N-1
        y(n+1) = y(n) + h * f(t(n), y(n));
    end
end

function [t, y] = implicitEuler(f, y0, t0, tf, h)
    % implicitEuler solves an ODE using the implicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Options for fsolve to increase accuracy and ensure convergence
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the implicit Euler method
    for n = 1:N-1
        % Define the function for the nonlinear equation at each step
        g = @(ynext) ynext - y(n) - h * f(t(n+1), ynext);
        
        % Use fsolve to solve for y(n+1)
        y(n+1) = fsolve(g, y(n), options);
    end
end

function [t, y] = trapMethod(f, y0, t0, tf, h)
    % trapMethod solves an ODE using the trapezoidal method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Options for fsolve to increase accuracy and ensure convergence
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the trapezoidal method
    for n = 1:N-1
        % Define the function for the nonlinear equation at each step
        g = @(ynext) ynext - y(n) - (h/2) * (f(t(n), y(n)) + f(t(n+1), ynext));
        
        % Use fsolve to solve for y(n+1)
        y(n+1) = fsolve(g, y(n), options);
    end
end

function [t, y] = RK2(f, y0, t0, tf, h)
    % RK2 solves an ODE using the 2nd-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the 2nd-order Runge-Kutta method
    for n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        y(n+1) = y(n) + h * k2;
    end
end

function [t, y] = RK4(f, y0, t0, tf, h)
    % RK4 solves an ODE using the 4th-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the 4th-order Runge-Kutta method
    for n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        k3 = f(t(n) + h/2, y(n) + h/2 * k2);
        k4 = f(t(n) + h, y(n) + h * k3);
        y(n+1) = y(n) + (h/6) * (k1 + 2*k2 + 2*k3 + k4);
    end
end

function [t, y1, y2] = explicitEuler_2(f, y0, v0, t0, tf, h)
    % A general second-order ODE y'' = f(t, y, y') 
    % using the explicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the explicit Euler method
    for n = 1:N-1
        % Update y1 and y2
        y1(n+1) = y1(n) + h * y2(n);
        y2(n+1) = y2(n) + h * f(t(n), y1(n), y2(n));
    end
end

function [t, y1, y2] = implicitEuler_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the implicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Options for fsolve
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the implicit Euler method
    for n = 1:N-1
        % Define the system of equations to solve at each step
        func = @(Y_next) [
            Y_next(1) - y1(n) - h * Y_next(2);          % y1^{n+1} = y1^n + h * y2^{n+1}
            Y_next(2) - y2(n) - h * f(t(n+1), Y_next(1), Y_next(2))  % y2^{n+1} = y2^n + h * f(t^{n+1}, y1^{n+1}, y2^{n+1})
        ];

        % Initial guess for fsolve
        Y_guess = [y1(n), y2(n)];

        % Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve
        Y_next = fsolve(func, Y_guess, options);

        % Update y1 and y2 with the solved values
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    end
end

function [t, y1, y2] = trapMethod_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the trapezoidal (implicit) method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Options for fsolve
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the trapezoidal method
    for n = 1:N-1
        % Define the system of equations to solve at each step
        func = @(Y_next) [
            Y_next(1) - y1(n) - h/2 * (y2(n) + Y_next(2));  % y1^{n+1} = y1^n + h/2 * (y2^n + y2^{n+1})
            Y_next(2) - y2(n) - h/2 * (f(t(n), y1(n), y2(n)) + f(t(n+1), Y_next(1), Y_next(2))) % y2^{n+1} = y2^n + h/2 * (f_n + f_{n+1})
        ];

        % Initial guess for fsolve
        Y_guess = [y1(n), y2(n)];

        % Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve
        Y_next = fsolve(func, Y_guess, options);

        % Update y1 and y2 with the solved values
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    end
end

function [t, y1, y2] = RK2_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the second-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the second-order Runge-Kutta method
    for n = 1:N-1
        % Calculate k1 values
        k1y1 = h * y2(n);
        k1y2 = h * f(t(n), y1(n), y2(n));

        % Calculate k2 values
        k2y1 = h * (y2(n) + k1y2 / 2);
        k2y2 = h * f(t(n) + h / 2, y1(n) + k1y1 / 2, y2(n) + k1y2 / 2);

        % Update y1 and y2
        y1(n+1) = y1(n) + k2y1;
        y2(n+1) = y2(n) + k2y2;
    end
end

function [t, y1, y2] = RK4_2(f, y0, v0, t0, tf, h)
    % RK4_2
 
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (y(t0) = y0)
    %   v0 - Initial condition for y' (y'(t0) = v0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y
    y2 = zeros(1, N); % Preallocate y2 for y'

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the 4th-order Runge-Kutta method
    for n = 1:N-1
        % Calculate k1 values
        k1_y1 = y2(n);
        k1_y2 = f(t(n), y1(n), y2(n));

        % Calculate k2 values
        k2_y1 = y2(n) + h/2 * k1_y2;
        k2_y2 = f(t(n) + h/2, y1(n) + h/2 * k1_y1, y2(n) + h/2 * k1_y2);

        % Calculate k3 values
        k3_y1 = y2(n) + h/2 * k2_y2;
        k3_y2 = f(t(n) + h/2, y1(n) + h/2 * k2_y1, y2(n) + h/2 * k2_y2);

        % Calculate k4 values
        k4_y1 = y2(n) + h * k3_y2;
        k4_y2 = f(t(n) + h, y1(n) + h * k3_y1, y2(n) + h * k3_y2);

        % Update y1 and y2 using weighted average of slopes
        y1(n+1) = y1(n) + (h/6) * (k1_y1 + 2*k2_y1 + 2*k3_y1 + k4_y1);
        y2(n+1) = y2(n) + (h/6) * (k1_y2 + 2*k2_y2 + 2*k3_y2 + k4_y2);
    end
end

##### SOURCE END #####
-->
</body>
</html>
