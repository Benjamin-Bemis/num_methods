
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>hw_5</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2024-11-14"><meta name="DC.source" content="hw_5.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Preperation of the workspace</a></li><li><a href="#3">Setting data paths</a></li><li><a href="#4">Problem 9 in Chapter 4</a></li><li><a href="#5">Problem 12</a></li><li><a href="#6">Functions</a></li></ul></div><pre class="codeinput"><span class="comment">%{
</span><span class="comment">
</span><span class="comment">@author: Benjamin Bemis Ph.D Student,
</span><span class="comment">Advisor: Dr Juliano
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">Description:
</span><span class="comment">AME 60614: Numerical Methods
</span><span class="comment">Homework: 5
</span><span class="comment">Due: 11/12/2024
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">%}</span>
</pre><h2 id="2">Preperation of the workspace</h2><pre class="codeinput">clear <span class="string">all</span>
clc
close <span class="string">all</span>
fontsize = 16;


<span class="comment">% set(0,'DefaultFigureWindowStyle','docked')</span>
set(0,<span class="string">'DefaultTextInterpreter'</span>,<span class="string">'latex'</span>)
set(0,<span class="string">'DefaultAxesFontSize'</span>,fontsize)
set(0,<span class="string">'DefaultLegendFontSize'</span>,fontsize)
colors  = [<span class="string">"#000000"</span>,<span class="string">"#1b9e77"</span>,<span class="string">"#d95f02"</span>,<span class="string">"#7570b3"</span>,<span class="string">"#0099FF"</span>]';
</pre><h2 id="3">Setting data paths</h2><p>Make sure to update this for the machine that you are working on. (Maybe, This should now run on any machine without change. 7/24/24) Change the current folder to the folder of this m-file.</p><pre class="codeinput"><span class="keyword">if</span>(~isdeployed)
  cd(fileparts(matlab.desktop.editor.getActiveFilename));
<span class="keyword">end</span>

addpath(cd)
<span class="comment">% cd ..; % Moving up a directory (from processing_code)</span>
basepath = cd; <span class="comment">% Pulling the current directory</span>

<span class="keyword">if</span> isunix

    imagepath = [basepath <span class="string">'/images/'</span>]; <span class="comment">% Unix</span>
    mkdir(imagepath);

<span class="keyword">elseif</span> ispc

    imagepath = [basepath <span class="string">'\images\'</span>]; <span class="comment">% Windows</span>
    mkdir(imagepath);

<span class="keyword">else</span>
    disp(<span class="string">'Platform not supported'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Warning: Directory already exists. 
</pre><h2 id="4">Problem 9 in Chapter 4</h2><pre class="codeinput">funlist = {@leapfrog, @AB2};
funlist_str = [<span class="string">"Leap Frog"</span>, <span class="string">"Adams - Bashforth"</span>];
<span class="comment">% funlist = {@leapfrog};</span>
<span class="comment">% funlist_str = ["Leap Frog"];</span>


exact = @(t) 10*cos(4.04351*t);
exact2 = @(t) exp(-2* t).* (5.6911* sin(3.51426 *t) + 10 *cos(3.51426*t));
g = 9.81; <span class="comment">%m/s^2</span>
l = 0.6; <span class="comment">%m</span>
c = 4;
theta0= 10; <span class="comment">%deg</span>
thetap0 = 0; <span class="comment">% assume at rest</span>
f_theta = @(t, theta, thetap) -g/l *theta ;
f_theta_2 = @(t, theta, thetap) -g/l *theta -c*thetap ;
start = 0;


t0 = 0;
tf = 6;
h = [0.1 0.2 0.5];
<span class="keyword">for</span> i = 1:length(funlist)
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(h)

        [t,y,yp] = funlist{i}(f_theta,theta0,thetap0, t0, tf, h(n), start);
        plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
        hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$\theta$ (deg)'</span>)
    legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-20 20])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q9_a_RK'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);



    figure
    plot(linspace(t0,tf,1e3),exact2(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
    hold <span class="string">on</span>
    <span class="keyword">for</span> n = 1:length(h)

        [t,y,yp] = funlist{i}(f_theta_2,theta0,thetap0, t0, tf, h(n),start);
        plot(t,y, <span class="string">"-."</span>, <span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>,strcat(<span class="string">"h = "</span>,string(h(n))) , color=colors(n+1,:))
        hold <span class="string">on</span>


    <span class="keyword">end</span>
    xlabel(<span class="string">'$t$ (sec)'</span>)
    ylabel(<span class="string">'$\theta$ (deg)'</span>)
    legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
    xlim([t0 tf])
    ylim([-20 20])
    grid <span class="string">on</span>
    title(funlist_str(i))
    set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
    print(gcf,[imagepath,<span class="string">'Q9_b_RK'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);



<span class="keyword">end</span>


A = [0 1; -g/l -c];

lamda_9 = eig(A)
</pre><pre class="codeoutput">
lamda_9 =

  -2.0000 + 3.5143i
  -2.0000 - 3.5143i

</pre><img vspace="5" hspace="5" src="hw_5_01.png" alt=""> <img vspace="5" hspace="5" src="hw_5_02.png" alt=""> <img vspace="5" hspace="5" src="hw_5_03.png" alt=""> <img vspace="5" hspace="5" src="hw_5_04.png" alt=""> <h2 id="5">Problem 12</h2><pre class="codeinput">y0 = - 1e-5;
f_12 = @(t, y) exp(y-t);
dfdy = @(t, y) exp(y-t);
exact_12 = @(t) -log(exp(-y0) + exp(-t) -1);
h = 0.2;

t0 = 0;
tf = 20;

[t_imp,y_imp] = implicitEuler(f_12, y0, t0, tf, h);
[t_lin,y_lin] = limplicitEuler(f_12, dfdy, y0, t0, tf, h);

figure
plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
hold <span class="string">on</span>
plot(t_imp, y_imp,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Implicit"</span>, color=colors(2,:))
hold <span class="string">on</span>
plot(t_lin, y_lin,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Linearized"</span>, color=colors(3,:))

xlabel(<span class="string">'$t$ (sec)'</span>)
ylabel(<span class="string">'$y$ '</span>)
legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
xlim([t0 tf])
ylim([0 15])
grid <span class="string">on</span>
title(<span class="string">"Linearized Solution"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q12_c'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);



figure
<span class="comment">% plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))</span>
<span class="comment">% hold on</span>
loglog(exact_12(t0:h:tf) - y_imp,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Implicit"</span>, color=colors(2,:))
hold <span class="string">on</span>
loglog(exact_12(t0:h:tf) - y_lin,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Linearized"</span>, color=colors(3,:))

xlabel(<span class="string">'$Elements$'</span>)
ylabel(<span class="string">'$Error$ '</span>)
legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
<span class="comment">% xlim([t0 tf])</span>
<span class="comment">% ylim([0 15])</span>
grid <span class="string">on</span>
title(<span class="string">"Linearized Error"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q12_c_err'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);


y0 = -1;
[t_imp,y_imp_2] = implicitEuler(f_12, y0, t0, tf, h);
[t_lin,y_lin_2] = limplicitEuler(f_12, dfdy, y0, t0, tf, h);


figure
plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Exact"</span>, color=colors(1,:))
hold <span class="string">on</span>
plot(t_imp, y_imp_2,<span class="string">":"</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Implicit"</span>, color=colors(2,:))
hold <span class="string">on</span>
plot(t_lin, y_lin_2,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Linearized"</span>, color=colors(3,:))

xlabel(<span class="string">'$t$ (sec)'</span>)
ylabel(<span class="string">'$y$ '</span>)
legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
xlim([t0 tf])
<span class="comment">% ylim([0 15])</span>
grid <span class="string">on</span>
title(<span class="string">"Linearized Solution"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q12_d'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);


figure
<span class="comment">% plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))</span>
<span class="comment">% hold on</span>
loglog(exact_12(t0:h:tf) - y_imp_2,<span class="string">":"</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Implicit"</span>, color=colors(2,:))
hold <span class="string">on</span>
loglog(exact_12(t0:h:tf) - y_lin_2,<span class="string">"-."</span>,<span class="string">"LineWidth"</span>,2, <span class="string">'DisplayName'</span>, <span class="string">"Linearized"</span>, color=colors(3,:))

xlabel(<span class="string">'$Elements$'</span>)
ylabel(<span class="string">'$Error$ '</span>)
legend(Location=<span class="string">"southeast"</span>,Interpreter=<span class="string">"latex"</span>)
<span class="comment">% xlim([t0 tf])</span>
<span class="comment">% ylim([0 15])</span>
grid <span class="string">on</span>
title(<span class="string">"Linearized Error"</span>)
set(gcf,<span class="string">'Position'</span>,[0,0,1000,500])
print(gcf,[imagepath,<span class="string">'Q12_d_err'</span>,char(string(i)),<span class="string">'.png'</span>],<span class="string">'-dpng'</span>);
</pre><img vspace="5" hspace="5" src="hw_5_05.png" alt=""> <img vspace="5" hspace="5" src="hw_5_06.png" alt=""> <img vspace="5" hspace="5" src="hw_5_07.png" alt=""> <img vspace="5" hspace="5" src="hw_5_08.png" alt=""> <h2 id="6">Functions</h2><pre class="codeinput"><span class="keyword">function</span> [t, y] = explicitEuler(f, y0, t0, tf, h)
    <span class="comment">% explicitEuler solves an ODE using the explicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the explicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        y(n+1) = y(n) + h * f(t(n), y(n));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = implicitEuler(f, y0, t0, tf, h)
    <span class="comment">% implicitEuler solves an ODE using the implicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Options for fsolve to increase accuracy and ensure convergence</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);
    <span class="comment">% options = optimoptions('fmincon', 'Display', 'off');</span>


    <span class="comment">% Apply the implicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the function for the nonlinear equation at each step</span>
        g = @(ynext) ynext - y(n) - h * f(t(n+1), ynext);

        <span class="comment">% Use fsolve to solve for y(n+1)</span>
        y(n+1) = fsolve(g, y(n), options);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = limplicitEuler(f, dfdy, y0, t0, tf, h)
    <span class="comment">% limplicitEuler solves a first-order ODE y' = f(t, y)</span>
    <span class="comment">% using a linearized implicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f    - Function handle for y' = f(t, y)</span>
    <span class="comment">%   dfdy - Function handle for the partial derivative of f with respect to y</span>
    <span class="comment">%   y0   - Initial condition for y</span>
    <span class="comment">%   t0   - Initial time</span>
    <span class="comment">%   tf   - Final time</span>
    <span class="comment">%   h    - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values for y at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for the solution</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the linearized implicit Euler method for each step</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Evaluate f and its derivative with respect to y at the current step</span>
        fn = f(t(n+1), y(n));
        dfdyn = dfdy(t(n+1), y(n));

        <span class="comment">% Calculate the next value of y using the linearized formula</span>
        y(n+1) = y(n) + ((h * fn) / (1 - h * dfdyn));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = trapMethod(f, y0, t0, tf, h)
    <span class="comment">% trapMethod solves an ODE using the trapezoidal method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Options for fsolve to increase accuracy and ensure convergence</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the trapezoidal method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the function for the nonlinear equation at each step</span>
        g = @(ynext) ynext - y(n) - (h/2) * (f(t(n), y(n)) + f(t(n+1), ynext));

        <span class="comment">% Use fsolve to solve for y(n+1)</span>
        y(n+1) = fsolve(g, y(n), options);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = RK2(f, y0, t0, tf, h)
    <span class="comment">% RK2 solves an ODE using the 2nd-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the 2nd-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        y(n+1) = y(n) + h * k2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y] = RK4(f, y0, t0, tf, h)
    <span class="comment">% RK4 solves an ODE using the 4th-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for dy/dt = f(t, y)</span>
    <span class="comment">%   y0 - Initial condition (value of y at t = t0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t - Array of time steps</span>
    <span class="comment">%   y - Array of solution values at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y = zeros(1, N); <span class="comment">% Preallocate y for speed</span>

    <span class="comment">% Set the initial condition</span>
    y(1) = y0;

    <span class="comment">% Apply the 4th-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        k3 = f(t(n) + h/2, y(n) + h/2 * k2);
        k4 = f(t(n) + h, y(n) + h * k3);
        y(n+1) = y(n) + (h/6) * (k1 + 2*k2 + 2*k3 + k4);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = explicitEuler_2(f, y0, v0, t0, tf, h)
    <span class="comment">% A general second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the explicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the explicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Update y1 and y2</span>
        y1(n+1) = y1(n) + h * y2(n);
        y2(n+1) = y2(n) + h * f(t(n), y1(n), y2(n));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = implicitEuler_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the implicit Euler method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Options for fsolve</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the implicit Euler method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the system of equations to solve at each step</span>
        func = @(Y_next) [
            Y_next(1) - y1(n) - h * Y_next(2);          <span class="comment">% y1^{n+1} = y1^n + h * y2^{n+1}</span>
            Y_next(2) - y2(n) - h * f(t(n+1), Y_next(1), Y_next(2))  <span class="comment">% y2^{n+1} = y2^n + h * f(t^{n+1}, y1^{n+1}, y2^{n+1})</span>
        ];

        <span class="comment">% Initial guess for fsolve</span>
        Y_guess = [y1(n), y2(n)];

        <span class="comment">% Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve</span>
        Y_next = fsolve(func, Y_guess, options);

        <span class="comment">% Update y1 and y2 with the solved values</span>
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = trapMethod_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the trapezoidal (implicit) method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Options for fsolve</span>
    options = optimoptions(<span class="string">'fsolve'</span>, <span class="string">'Display'</span>, <span class="string">'off'</span>);

    <span class="comment">% Apply the trapezoidal method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Define the system of equations to solve at each step</span>
        func = @(Y_next) [
            Y_next(1) - y1(n) - h/2 * (y2(n) + Y_next(2));  <span class="comment">% y1^{n+1} = y1^n + h/2 * (y2^n + y2^{n+1})</span>
            Y_next(2) - y2(n) - h/2 * (f(t(n), y1(n), y2(n)) + f(t(n+1), Y_next(1), Y_next(2))) <span class="comment">% y2^{n+1} = y2^n + h/2 * (f_n + f_{n+1})</span>
        ];

        <span class="comment">% Initial guess for fsolve</span>
        Y_guess = [y1(n), y2(n)];

        <span class="comment">% Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve</span>
        Y_next = fsolve(func, Y_guess, options);

        <span class="comment">% Update y1 and y2 with the solved values</span>
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = RK2_2(f, y0, v0, t0, tf, h)
    <span class="comment">% General second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the second-order Runge-Kutta method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the second-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Calculate k1 values</span>
        k1y1 = h * y2(n);
        k1y2 = h * f(t(n), y1(n), y2(n));

        <span class="comment">% Calculate k2 values</span>
        k2y1 = h * (y2(n) + k1y2 / 2);
        k2y2 = h * f(t(n) + h / 2, y1(n) + k1y1 / 2, y2(n) + k1y2 / 2);

        <span class="comment">% Update y1 and y2</span>
        y1(n+1) = y1(n) + k2y1;
        y2(n+1) = y2(n) + k2y2;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = RK4_2(f, y0, v0, t0, tf, h)

    <span class="comment">% RK4_2</span>

    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (y(t0) = y0)</span>
    <span class="comment">%   v0 - Initial condition for y' (y'(t0) = v0)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y'</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

    <span class="comment">% Apply the 4th-order Runge-Kutta method</span>
    <span class="keyword">for</span> n = 1:N-1
        <span class="comment">% Calculate k1 values</span>
        k1_y1 = y2(n);
        k1_y2 = f(t(n), y1(n), y2(n));

        <span class="comment">% Calculate k2 values</span>
        k2_y1 = y2(n) + h/2 * k1_y2;
        k2_y2 = f(t(n) + h/2, y1(n) + h/2 * k1_y1, y2(n) + h/2 * k1_y2);

        <span class="comment">% Calculate k3 values</span>
        k3_y1 = y2(n) + h/2 * k2_y2;
        k3_y2 = f(t(n) + h/2, y1(n) + h/2 * k2_y1, y2(n) + h/2 * k2_y2);

        <span class="comment">% Calculate k4 values</span>
        k4_y1 = y2(n) + h * k3_y2;
        k4_y2 = f(t(n) + h, y1(n) + h * k3_y1, y2(n) + h * k3_y2);

        <span class="comment">% Update y1 and y2 using weighted average of slopes</span>
        y1(n+1) = y1(n) + (h/6) * (k1_y1 + 2*k2_y1 + 2*k3_y1 + k4_y1);
        y2(n+1) = y2(n) + (h/6) * (k1_y2 + 2*k2_y2 + 2*k3_y2 + k4_y2);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = AB2(f, y0, v0, t0, tf, h, start)
    <span class="comment">% AB2 solves a general second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the second-order Adams-Bashforth method.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%   start - Start method</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

<span class="keyword">if</span> start == 1

    <span class="comment">% Use explicit Euler for the first step to get y1(2) and y2(2)</span>
    y1(2) = y1(1) + h * y2(1);
    y2(2) = y2(1) + h * f(t(1), y1(1), y2(1));

<span class="keyword">else</span>
    <span class="comment">% Use RK2 for the first step</span>
    k1y1 = h * y2(1);
    k1y2 = h * f(t(1), y1(1), y2(1));

    <span class="comment">% Calculate k2 values</span>
    k2y1 = h * (y2(1) + k1y2 / 2);
    k2y2 = h * f(t(1) + h / 2, y1(1) + k1y1 / 2, y2(1) + k1y2 / 2);

    <span class="comment">% Update y1 and y2</span>
    y1(2) = y1(1) + k2y1;
    y2(2) = y2(1) + k2y2;
<span class="keyword">end</span>

    <span class="comment">% Apply the Adams-Bashforth method for the rest of the steps</span>
    <span class="keyword">for</span> n = 2:N-1
        <span class="comment">% Update y1 and y2 using the Adams-Bashforth formula</span>
        y1(n+1) = y1(n) + h * (3/2 * y2(n) - 1/2 * y2(n-1));
        y2(n+1) = y2(n) + h * (3/2 * f(t(n), y1(n), y2(n)) - 1/2 * f(t(n-1), y1(n-1), y2(n-1)));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [t, y1, y2] = leapfrog(f, y0, v0, t0, tf, h, start)
    <span class="comment">% leapfrog solves a general second-order ODE y'' = f(t, y, y')</span>
    <span class="comment">% using the leapfrog method with an explicit Euler or RK2 start.</span>
    <span class="comment">%</span>
    <span class="comment">% Inputs:</span>
    <span class="comment">%   f  - Function handle for y'' = f(t, y, y')</span>
    <span class="comment">%   y0 - Initial condition for y (position)</span>
    <span class="comment">%   v0 - Initial condition for y' (velocity)</span>
    <span class="comment">%   t0 - Initial time</span>
    <span class="comment">%   tf - Final time</span>
    <span class="comment">%   h  - Step size</span>
    <span class="comment">%   start - Start method</span>
    <span class="comment">%</span>
    <span class="comment">% Outputs:</span>
    <span class="comment">%   t  - Array of time steps</span>
    <span class="comment">%   y1 - Array of solution values for y at each time step</span>
    <span class="comment">%   y2 - Array of solution values for y' at each time step</span>

    <span class="comment">% Define the time vector from t0 to tf with step size h</span>
    t = t0:h:tf;
    N = length(t); <span class="comment">% Number of time steps</span>
    y1 = zeros(1, N); <span class="comment">% Preallocate y1 for y (position)</span>
    y2 = zeros(1, N); <span class="comment">% Preallocate y2 for y' (velocity)</span>

    <span class="comment">% Set the initial conditions</span>
    y1(1) = y0;
    y2(1) = v0;

<span class="keyword">if</span> start == 1

    <span class="comment">% Use explicit Euler for the first step to get y1(2) and y2(2)</span>
    y1(2) = y1(1) + h * y2(1);
    y2(2) = y2(1) + h * f(t(1), y1(1), y2(1));

<span class="keyword">else</span>
    <span class="comment">% Use RK2 for the first step</span>
    k1y1 = h * y2(1);
    k1y2 = h * f(t(1), y1(1), y2(1));

    <span class="comment">% Calculate k2 values</span>
    k2y1 = h * (y2(1) + k1y2 / 2);
    k2y2 = h * f(t(1) + h / 2, y1(1) + k1y1 / 2, y2(1) + k1y2 / 2);

    <span class="comment">% Update y1 and y2</span>
    y1(2) = y1(1) + k2y1;
    y2(2) = y2(1) + k2y2;
<span class="keyword">end</span>

    <span class="comment">% Apply the leapfrog method for the rest of the steps</span>
    <span class="keyword">for</span> n = 2:N-1
        <span class="comment">% Full-step for position</span>
        y1(n+1) = y1(n-1) + 2*h * y2(n);

        <span class="comment">% Full-step for velocity</span>
        y2(n+1) = y2(n-1) + 2*h * f(t(n), y1(n), y2(n));

    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%{

@author: Benjamin Bemis Ph.D Student, 
Advisor: Dr Juliano


Description:
AME 60614: Numerical Methods
Homework: 5
Due: 11/12/2024


%}

%% Preperation of the workspace
clear all 
clc 
close all
fontsize = 16;


% set(0,'DefaultFigureWindowStyle','docked')
set(0,'DefaultTextInterpreter','latex')
set(0,'DefaultAxesFontSize',fontsize)
set(0,'DefaultLegendFontSize',fontsize)
colors  = ["#000000","#1b9e77","#d95f02","#7570b3","#0099FF"]';

%% Setting data paths
% Make sure to update this for the machine that you are working on. (Maybe, This should now run on any machine without change. 7/24/24)
% Change the current folder to the folder of this m-file.
if(~isdeployed)
  cd(fileparts(matlab.desktop.editor.getActiveFilename));
end

addpath(cd)
% cd ..; % Moving up a directory (from processing_code)
basepath = cd; % Pulling the current directory

if isunix

    imagepath = [basepath '/images/']; % Unix
    mkdir(imagepath);

elseif ispc

    imagepath = [basepath '\images\']; % Windows
    mkdir(imagepath);

else
    disp('Platform not supported')
end


%% Problem 9 in Chapter 4
funlist = {@leapfrog, @AB2};
funlist_str = ["Leap Frog", "Adams - Bashforth"];
% funlist = {@leapfrog};
% funlist_str = ["Leap Frog"];


exact = @(t) 10*cos(4.04351*t);
exact2 = @(t) exp(-2* t).* (5.6911* sin(3.51426 *t) + 10 *cos(3.51426*t));
g = 9.81; %m/s^2
l = 0.6; %m
c = 4; 
theta0= 10; %deg
thetap0 = 0; % assume at rest
f_theta = @(t, theta, thetap) -g/l *theta ; 
f_theta_2 = @(t, theta, thetap) -g/l *theta -c*thetap ; 
start = 0;


t0 = 0;
tf = 6;
h = [0.1 0.2 0.5];
for i = 1:length(funlist) 
    figure
    plot(linspace(t0,tf,1e3),exact(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(h)

        [t,y,yp] = funlist{i}(f_theta,theta0,thetap0, t0, tf, h(n), start);
        plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
        hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$\theta$ (deg)')
    legend(Location="southeast",Interpreter="latex")
    xlim([t0 tf])
    ylim([-20 20])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q9_a_RK',char(string(i)),'.png'],'-dpng');



    figure
    plot(linspace(t0,tf,1e3),exact2(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
    hold on
    for n = 1:length(h)

        [t,y,yp] = funlist{i}(f_theta_2,theta0,thetap0, t0, tf, h(n),start);
        plot(t,y, "-.", "LineWidth",2, 'DisplayName',strcat("h = ",string(h(n))) , color=colors(n+1,:))
        hold on


    end
    xlabel('$t$ (sec)')
    ylabel('$\theta$ (deg)')
    legend(Location="southeast",Interpreter="latex")
    xlim([t0 tf])
    ylim([-20 20])
    grid on
    title(funlist_str(i))
    set(gcf,'Position',[0,0,1000,500])
    print(gcf,[imagepath,'Q9_b_RK',char(string(i)),'.png'],'-dpng');



end


A = [0 1; -g/l -c];

lamda_9 = eig(A)

%% Problem 12
y0 = - 1e-5;
f_12 = @(t, y) exp(y-t);
dfdy = @(t, y) exp(y-t); 
exact_12 = @(t) -log(exp(-y0) + exp(-t) -1);
h = 0.2; 

t0 = 0;
tf = 20;

[t_imp,y_imp] = implicitEuler(f_12, y0, t0, tf, h);
[t_lin,y_lin] = limplicitEuler(f_12, dfdy, y0, t0, tf, h);

figure
plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
hold on
plot(t_imp, y_imp,"-.","LineWidth",2, 'DisplayName', "Implicit", color=colors(2,:))
hold on 
plot(t_lin, y_lin,"-.","LineWidth",2, 'DisplayName', "Linearized", color=colors(3,:))

xlabel('$t$ (sec)')
ylabel('$y$ ')
legend(Location="southeast",Interpreter="latex")
xlim([t0 tf])
ylim([0 15])
grid on
title("Linearized Solution")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q12_c',char(string(i)),'.png'],'-dpng');



figure
% plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
% hold on
loglog(exact_12(t0:h:tf) - y_imp,"-.","LineWidth",2, 'DisplayName', "Implicit", color=colors(2,:))
hold on 
loglog(exact_12(t0:h:tf) - y_lin,"-.","LineWidth",2, 'DisplayName', "Linearized", color=colors(3,:))

xlabel('$Elements$')
ylabel('$Error$ ')
legend(Location="southeast",Interpreter="latex")
% xlim([t0 tf])
% ylim([0 15])
grid on
title("Linearized Error")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q12_c_err',char(string(i)),'.png'],'-dpng');


y0 = -1;
[t_imp,y_imp_2] = implicitEuler(f_12, y0, t0, tf, h);
[t_lin,y_lin_2] = limplicitEuler(f_12, dfdy, y0, t0, tf, h);


figure
plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
hold on
plot(t_imp, y_imp_2,":","LineWidth",2, 'DisplayName', "Implicit", color=colors(2,:))
hold on 
plot(t_lin, y_lin_2,"-.","LineWidth",2, 'DisplayName', "Linearized", color=colors(3,:))

xlabel('$t$ (sec)')
ylabel('$y$ ')
legend(Location="southeast",Interpreter="latex")
xlim([t0 tf])
% ylim([0 15])
grid on
title("Linearized Solution")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q12_d',char(string(i)),'.png'],'-dpng');


figure
% plot(linspace(t0,tf,1e3),exact_12(linspace(t0,tf,1e3)),"LineWidth",2, 'DisplayName', "Exact", color=colors(1,:))
% hold on
loglog(exact_12(t0:h:tf) - y_imp_2,":","LineWidth",2, 'DisplayName', "Implicit", color=colors(2,:))
hold on 
loglog(exact_12(t0:h:tf) - y_lin_2,"-.","LineWidth",2, 'DisplayName', "Linearized", color=colors(3,:))

xlabel('$Elements$')
ylabel('$Error$ ')
legend(Location="southeast",Interpreter="latex")
% xlim([t0 tf])
% ylim([0 15])
grid on
title("Linearized Error")
set(gcf,'Position',[0,0,1000,500])
print(gcf,[imagepath,'Q12_d_err',char(string(i)),'.png'],'-dpng');


%% Functions

function [t, y] = explicitEuler(f, y0, t0, tf, h)
    % explicitEuler solves an ODE using the explicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the explicit Euler method
    for n = 1:N-1
        y(n+1) = y(n) + h * f(t(n), y(n));
    end
end

function [t, y] = implicitEuler(f, y0, t0, tf, h)
    % implicitEuler solves an ODE using the implicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Options for fsolve to increase accuracy and ensure convergence
    options = optimoptions('fsolve', 'Display', 'off');
    % options = optimoptions('fmincon', 'Display', 'off');


    % Apply the implicit Euler method
    for n = 1:N-1
        % Define the function for the nonlinear equation at each step
        g = @(ynext) ynext - y(n) - h * f(t(n+1), ynext);
        
        % Use fsolve to solve for y(n+1)
        y(n+1) = fsolve(g, y(n), options);
    end
end

function [t, y] = limplicitEuler(f, dfdy, y0, t0, tf, h)
    % limplicitEuler solves a first-order ODE y' = f(t, y)
    % using a linearized implicit Euler method.
    %
    % Inputs:
    %   f    - Function handle for y' = f(t, y)
    %   dfdy - Function handle for the partial derivative of f with respect to y
    %   y0   - Initial condition for y
    %   t0   - Initial time
    %   tf   - Final time
    %   h    - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values for y at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for the solution

    % Set the initial condition
    y(1) = y0;

    % Apply the linearized implicit Euler method for each step
    for n = 1:N-1
        % Evaluate f and its derivative with respect to y at the current step
        fn = f(t(n+1), y(n));
        dfdyn = dfdy(t(n+1), y(n));

        % Calculate the next value of y using the linearized formula
        y(n+1) = y(n) + ((h * fn) / (1 - h * dfdyn));
    end
end

function [t, y] = trapMethod(f, y0, t0, tf, h)
    % trapMethod solves an ODE using the trapezoidal method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Options for fsolve to increase accuracy and ensure convergence
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the trapezoidal method
    for n = 1:N-1
        % Define the function for the nonlinear equation at each step
        g = @(ynext) ynext - y(n) - (h/2) * (f(t(n), y(n)) + f(t(n+1), ynext));
        
        % Use fsolve to solve for y(n+1)
        y(n+1) = fsolve(g, y(n), options);
    end
end

function [t, y] = RK2(f, y0, t0, tf, h)
    % RK2 solves an ODE using the 2nd-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the 2nd-order Runge-Kutta method
    for n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        y(n+1) = y(n) + h * k2;
    end
end

function [t, y] = RK4(f, y0, t0, tf, h)
    % RK4 solves an ODE using the 4th-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for dy/dt = f(t, y)
    %   y0 - Initial condition (value of y at t = t0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t - Array of time steps
    %   y - Array of solution values at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y = zeros(1, N); % Preallocate y for speed

    % Set the initial condition
    y(1) = y0;

    % Apply the 4th-order Runge-Kutta method
    for n = 1:N-1
        k1 = f(t(n), y(n));
        k2 = f(t(n) + h/2, y(n) + h/2 * k1);
        k3 = f(t(n) + h/2, y(n) + h/2 * k2);
        k4 = f(t(n) + h, y(n) + h * k3);
        y(n+1) = y(n) + (h/6) * (k1 + 2*k2 + 2*k3 + k4);
    end
end

function [t, y1, y2] = explicitEuler_2(f, y0, v0, t0, tf, h)
    % A general second-order ODE y'' = f(t, y, y') 
    % using the explicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the explicit Euler method
    for n = 1:N-1
        % Update y1 and y2
        y1(n+1) = y1(n) + h * y2(n);
        y2(n+1) = y2(n) + h * f(t(n), y1(n), y2(n));
    end
end

function [t, y1, y2] = implicitEuler_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the implicit Euler method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Options for fsolve
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the implicit Euler method
    for n = 1:N-1
        % Define the system of equations to solve at each step
        func = @(Y_next) [
            Y_next(1) - y1(n) - h * Y_next(2);          % y1^{n+1} = y1^n + h * y2^{n+1}
            Y_next(2) - y2(n) - h * f(t(n+1), Y_next(1), Y_next(2))  % y2^{n+1} = y2^n + h * f(t^{n+1}, y1^{n+1}, y2^{n+1})
        ];

        % Initial guess for fsolve
        Y_guess = [y1(n), y2(n)];

        % Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve
        Y_next = fsolve(func, Y_guess, options);

        % Update y1 and y2 with the solved values
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    end
end

function [t, y1, y2] = trapMethod_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the trapezoidal (implicit) method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Options for fsolve
    options = optimoptions('fsolve', 'Display', 'off');

    % Apply the trapezoidal method
    for n = 1:N-1
        % Define the system of equations to solve at each step
        func = @(Y_next) [
            Y_next(1) - y1(n) - h/2 * (y2(n) + Y_next(2));  % y1^{n+1} = y1^n + h/2 * (y2^n + y2^{n+1})
            Y_next(2) - y2(n) - h/2 * (f(t(n), y1(n), y2(n)) + f(t(n+1), Y_next(1), Y_next(2))) % y2^{n+1} = y2^n + h/2 * (f_n + f_{n+1})
        ];

        % Initial guess for fsolve
        Y_guess = [y1(n), y2(n)];

        % Solve for Y_next = [y1^{n+1}; y2^{n+1}] using fsolve
        Y_next = fsolve(func, Y_guess, options);

        % Update y1 and y2 with the solved values
        y1(n+1) = Y_next(1);
        y2(n+1) = Y_next(2);
    end
end

function [t, y1, y2] = RK2_2(f, y0, v0, t0, tf, h)
    % General second-order ODE y'' = f(t, y, y')
    % using the second-order Runge-Kutta method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the second-order Runge-Kutta method
    for n = 1:N-1
        % Calculate k1 values
        k1y1 = h * y2(n);
        k1y2 = h * f(t(n), y1(n), y2(n));

        % Calculate k2 values
        k2y1 = h * (y2(n) + k1y2 / 2);
        k2y2 = h * f(t(n) + h / 2, y1(n) + k1y1 / 2, y2(n) + k1y2 / 2);

        % Update y1 and y2
        y1(n+1) = y1(n) + k2y1;
        y2(n+1) = y2(n) + k2y2;
    end
end

function [t, y1, y2] = RK4_2(f, y0, v0, t0, tf, h)

    % RK4_2
 
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (y(t0) = y0)
    %   v0 - Initial condition for y' (y'(t0) = v0)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y
    y2 = zeros(1, N); % Preallocate y2 for y'

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

    % Apply the 4th-order Runge-Kutta method
    for n = 1:N-1
        % Calculate k1 values
        k1_y1 = y2(n);
        k1_y2 = f(t(n), y1(n), y2(n));

        % Calculate k2 values
        k2_y1 = y2(n) + h/2 * k1_y2;
        k2_y2 = f(t(n) + h/2, y1(n) + h/2 * k1_y1, y2(n) + h/2 * k1_y2);

        % Calculate k3 values
        k3_y1 = y2(n) + h/2 * k2_y2;
        k3_y2 = f(t(n) + h/2, y1(n) + h/2 * k2_y1, y2(n) + h/2 * k2_y2);

        % Calculate k4 values
        k4_y1 = y2(n) + h * k3_y2;
        k4_y2 = f(t(n) + h, y1(n) + h * k3_y1, y2(n) + h * k3_y2);

        % Update y1 and y2 using weighted average of slopes
        y1(n+1) = y1(n) + (h/6) * (k1_y1 + 2*k2_y1 + 2*k3_y1 + k4_y1);
        y2(n+1) = y2(n) + (h/6) * (k1_y2 + 2*k2_y2 + 2*k3_y2 + k4_y2);
    end
end

function [t, y1, y2] = AB2(f, y0, v0, t0, tf, h, start)
    % AB2 solves a general second-order ODE y'' = f(t, y, y')
    % using the second-order Adams-Bashforth method.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %   start - Start method
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

if start == 1

    % Use explicit Euler for the first step to get y1(2) and y2(2)
    y1(2) = y1(1) + h * y2(1);
    y2(2) = y2(1) + h * f(t(1), y1(1), y2(1));

else
    % Use RK2 for the first step
    k1y1 = h * y2(1);
    k1y2 = h * f(t(1), y1(1), y2(1));

    % Calculate k2 values
    k2y1 = h * (y2(1) + k1y2 / 2);
    k2y2 = h * f(t(1) + h / 2, y1(1) + k1y1 / 2, y2(1) + k1y2 / 2);

    % Update y1 and y2
    y1(2) = y1(1) + k2y1;
    y2(2) = y2(1) + k2y2;
end

    % Apply the Adams-Bashforth method for the rest of the steps
    for n = 2:N-1
        % Update y1 and y2 using the Adams-Bashforth formula
        y1(n+1) = y1(n) + h * (3/2 * y2(n) - 1/2 * y2(n-1));
        y2(n+1) = y2(n) + h * (3/2 * f(t(n), y1(n), y2(n)) - 1/2 * f(t(n-1), y1(n-1), y2(n-1)));
    end
end

function [t, y1, y2] = leapfrog(f, y0, v0, t0, tf, h, start)
    % leapfrog solves a general second-order ODE y'' = f(t, y, y')
    % using the leapfrog method with an explicit Euler or RK2 start.
    %
    % Inputs:
    %   f  - Function handle for y'' = f(t, y, y')
    %   y0 - Initial condition for y (position)
    %   v0 - Initial condition for y' (velocity)
    %   t0 - Initial time
    %   tf - Final time
    %   h  - Step size
    %   start - Start method
    %
    % Outputs:
    %   t  - Array of time steps
    %   y1 - Array of solution values for y at each time step
    %   y2 - Array of solution values for y' at each time step

    % Define the time vector from t0 to tf with step size h
    t = t0:h:tf;
    N = length(t); % Number of time steps
    y1 = zeros(1, N); % Preallocate y1 for y (position)
    y2 = zeros(1, N); % Preallocate y2 for y' (velocity)

    % Set the initial conditions
    y1(1) = y0;
    y2(1) = v0;

if start == 1

    % Use explicit Euler for the first step to get y1(2) and y2(2)
    y1(2) = y1(1) + h * y2(1);
    y2(2) = y2(1) + h * f(t(1), y1(1), y2(1));

else
    % Use RK2 for the first step
    k1y1 = h * y2(1);
    k1y2 = h * f(t(1), y1(1), y2(1));

    % Calculate k2 values
    k2y1 = h * (y2(1) + k1y2 / 2);
    k2y2 = h * f(t(1) + h / 2, y1(1) + k1y1 / 2, y2(1) + k1y2 / 2);

    % Update y1 and y2
    y1(2) = y1(1) + k2y1;
    y2(2) = y2(1) + k2y2;
end
   
    % Apply the leapfrog method for the rest of the steps
    for n = 2:N-1
        % Full-step for position
        y1(n+1) = y1(n-1) + 2*h * y2(n);

        % Full-step for velocity
        y2(n+1) = y2(n-1) + 2*h * f(t(n), y1(n), y2(n));

    end
end


##### SOURCE END #####
--></body></html>